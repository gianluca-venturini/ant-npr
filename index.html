<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>

		<script type="x-shader/x-vertex" id="randomVertexShader">
			varying vec2 vUv;

			void main() {
				vUv = uv;

				gl_Position = vec4(position,1.0);
			}
		</script>

		<script type="x-shader/x-fragment" id="randomFragmentShader">

			varying vec2 vUv;

			float rand(vec2 co){
				return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
			}

			void main() {
				if(rand(vUv) < 0.01) {
					gl_FragColor = vec4(1,0,1,1);
				}
				else {
					gl_FragColor = vec4(0,0,0,0);
				}
				//gl_FragColor = vec4(0, 0, 0, 0); // Works; Displays Flat Color
			}
		</script>

		<script type="x-shader/x-vertex" id="antVertexShader">
			varying vec2 vUv;

			void main() {
				vUv = uv;

				gl_Position = vec4(position,1.0);
			}
		</script>

		<script type="x-shader/x-fragment" id="antFragmentShader">
			uniform sampler2D antTexture;
			uniform sampler2D livingTexture;
			uniform vec2 sensoryVectors[5];
			uniform float sensoryWeights[5];

			uniform float dx;
			uniform float dy;

			varying vec2 vUv;

			vec2 rotate(vec2 v, float angle) {
				mat3 rotation = mat3(
										cos(angle), -sin(angle), 0.0,
										sin(angle),  cos(angle), 0.0,
										0.0		  , 0.0		   , 1.0
									);
				return (rotation * vec3(v, 0.0)).xy;

			}

			vec2 move(vec2 point) {
				vec2 dp = vec2(0,0);
				for(int i=0; i<5; i++) {
					float wi = sensoryWeights[i];

					vec2 dir = vec2(texture2D(antTexture, point).x - 0.5, texture2D(antTexture, point).y - 0.5);

					float angle = acos(dot(vec2(1.0, 0.0), dir) / length(dir));

					vec2  sv = normalize(rotate(sensoryVectors[i], angle));

					vec2 svn = vec2(sv.x * 5.0 * dx, sv.y * 5.0 * dy);
					float luminance = texture2D(livingTexture, point+svn).x + texture2D(livingTexture, point+svn).y + texture2D(livingTexture, point+svn).z;
					dp += 0.003 * (sv/length(sv)) * luminance * wi;	// Multiply vel
				}

				// Clamping
				dp = vec2( clamp(dp.x, -dx * 2.0, dx * 2.0), clamp(dp.y * 2.0, -dy * 2.0, dy * 2.0) );

				return dp;

			}

			void main() {
				/*
				vec4 NW = texture2D(antCopyTexture, vec2(vUv.x - dx, vUv.y - dy));
				vec4 N  = texture2D(antCopyTexture, vec2(vUv.x     , vUv.y - dy));
				vec4 NE = texture2D(antCopyTexture, vec2(vUv.x + dx, vUv.y - dy));
				vec4 E  = texture2D(antCopyTexture, vec2(vUv.x - dx, vUv.y     ));
				vec4 W  = texture2D(antCopyTexture, vec2(vUv.x + dx, vUv.y     ));
				vec4 SW = texture2D(antCopyTexture, vec2(vUv.x - dx, vUv.y + dy));
				vec4 S  = texture2D(antCopyTexture, vec2(vUv.x     , vUv.y + dy));
				vec4 SE = texture2D(antCopyTexture, vec2(vUv.x - dx, vUv.y + dy));
				*/

				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);

				vec4 ant = vec4(0.0, 0.0, 0.0, 0.0);

				for(int i = 0; i < 7; i++)
					for(int j = 0; j < 7; j++) {
						if(j != 3 || i != 3) {
							vec2 p = vUv;
							p.x += (float(i)-3.0) * dx;
							p.y += (float(j)-3.0) * dy;
							vec4 a = texture2D(antTexture, p);

							if(a.z != 0.0 && p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0) {
								vec2 dir  = move(p);
								vec2 newP = dir + p;

								if(abs(newP.x - vUv.x) < dx/2.0 && abs(newP.y - vUv.y) < dy/2.0) {
									ant = texture2D(antTexture, p);

									vec2 d = normalize(dir) / 2.0;
									gl_FragColor = vec4(d.x + 0.5, d.y + 0.5, 1.0, 1.0);
								}
							}
						}
					}

				//gl_FragColor = vec4(0.5, 0.2, 1.0, 1.0); // Works; Displays Flat Color
			}
		</script>

		<script type="x-shader/x-vertex" id="antCopyVertexShader">
			varying vec2 vUv;

			void main() {
				vUv = uv;

				gl_Position = vec4(position,1.0);
			}
		</script>

		<script type="x-shader/x-fragment" id="antCopyFragmentShader">
			uniform sampler2D antTexture;
			uniform sampler2D livingTexture;

			uniform float dx;
			uniform float dy;

			varying vec2 vUv;

			void main() {
				vec2 p = vUv;

				if(texture2D(antTexture, p).z != 0.0) {
					gl_FragColor.x = p.x + dx;
					gl_FragColor.y = p.y;

					gl_FragColor.z = texture2D(antTexture, p).z;
					gl_FragColor.w = texture2D(antTexture, p).w;
				}
				else
					gl_FragColor = vec4(0, 0, 0, 0);
				//gl_FragColor = vec4(0.5, 0.2, 1.0, 1.0); // Works; Displays Flat Color
			}
		</script>

		<script type="x-shader/x-vertex" id="livingVertexShader">
			varying vec2 vUv;

			void main() {
				vUv = uv;

				gl_Position = vec4(position,1.0);
			}
		</script>

		<script type="x-shader/x-fragment" id="livingFragmentShader">
			uniform sampler2D livingTexture;

			varying vec2 vUv;

			void main() {
				vec2 p = vUv;
				gl_FragColor = texture2D(livingTexture, p);// Displays Nothing
				//gl_FragColor = vec4(0.5, 0.2, 1.0, 1.0); // Works; Displays Flat Color
			}
		</script>

		<script type="x-shader/x-vertex" id="paintingVertexShader">
			varying vec2 vUv;

			void main() {
				vUv = uv;

				gl_Position = vec4(position,1.0);
			}
		</script>

		<script type="x-shader/x-fragment" id="paintingFragmentShader">
			uniform sampler2D paintingTexture;

			varying vec2 vUv;

			void main() {
				vec2 p = vUv;
				gl_FragColor = texture2D(paintingTexture, p) + vec4(0.5, 0, 0, 0); // Displays Nothing
				//gl_FragColor = vec4(0.5, 0.2, 1.0, 1.0); // Works; Displays Flat Color
			}
		</script>

		<script type="x-shader/x-vertex" id="finalVertexShader">
			varying vec2 vUv;

			void main() {
				vUv = uv;

				gl_Position = vec4(position,1.0);
			}
		</script>

		<script type="x-shader/x-fragment" id="finalFragmentShader">
			uniform sampler2D paintingTexture;

			varying vec2 vUv;

			void main() {
				vec2 p = vUv;
				gl_FragColor = texture2D(paintingTexture, p);// + vec4(0,0,0.5,0); // Displays Nothing
				//gl_FragColor = vec4(0.5, 0.2, 1.0, 1.0); // Works; Displays Flat Color
			}
		</script>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script>
			var camera;

			var renderer;

			// Meshes
			var randomMesh;
			var paintingMesh;
			var livingMesh;
			var antMesh;
			var antCopyMesh;
			var finalMesh;

			// Textures
			var painting;
			var living;
			var antCopy;
			var ant;

			// First execution
			var firstExecution = true;

			// Scenes
			var randomScene;
			var paintingScene;
			var livingScene;
			var antCopyScene;
			var antScene;
			var finalScene;

			// Uniforms
			var randomUniforms;
			var paintingUniforms;
			var livingUniforms;
			var antCopyUniforms;
			var antUniforms;
			var finalUniforms;

			// Parameters
			var gain;
			var decay;
			var consRate;
			var depositRate;
			var depositTransp;
			var dTranspMax;
			var dTranspMin;
			var initialEnergy;
			var deathTreshold;
			var descVelMin;
			var descVelMax;
			var vel;
			var noiseMin;
			var noiseMax;
			var initialPositions;
			var sensoryVectors = [new THREE.Vector2( 0.1,  0.0 ),
								  new THREE.Vector2( 0.1,  0.4 ),
								  new THREE.Vector2( 0.1,  0.8 ),
								  new THREE.Vector2( 0.1, -0.4 ),
								  new THREE.Vector2( 0.1, -0.8 )];
			var sensoryWeights = [0.1, 0.25, 0.2, 0.25, 0.2];
			 
			init();
			//animate();

			function init() {

				// Scenes
				randomScene   = new THREE.Scene();
				paintingScene = new THREE.Scene();
				livingScene   = new THREE.Scene();
				antCopyScene  = new THREE.Scene();
				antScene      = new THREE.Scene();
				finalScene    = new THREE.Scene();

				// Use only this camera
			    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000);
				camera.position.z = 1;

				randomScene.add(camera);
				paintingScene.add(camera);
				livingScene.add(camera);
				antCopyScene.add(camera);
				antScene.add(camera);
				finalScene.add(camera);

				// Create textures
				painting = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				living   = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } ); // THREE.ImageUtils.loadTexture("image/sea.jpg", {}, function() {living["loaded"] = true;});
				antCopy	 = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } ); // THREE.ImageUtils.loadTexture("image/sea.jpg", {}, function() {ant["loaded"] = true;});
				ant 	 = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } ); // THREE.ImageUtils.loadTexture("image/sea.jpg", {}, function() {ant["loaded"] = true;});

				var height = 2;
				var width  = 2;

				// Create uniforms
				randomUniforms = {
				};

				paintingUniforms = {
					paintingTexture: { type: "t", value: painting }
				};

				livingUniforms = {
					livingTexture: { type: "t", value: initLiving }
				};

				antCopyUniforms = {
					antTexture: { type: "t", value: antCopy },
					livingTexture: { type: "t", value: living },
					dx: { type: "f", value: 1/window.innerWidth},
					dy: { type: "f", value: 1/window.innerHeight},
				};

				antUniforms = {
					antTexture: { type: "t", value: ant },
					livingTexture: { type: "t", value: living },
					dx: { type: "f", value: 1/window.innerWidth},
					dy: { type: "f", value: 1/window.innerHeight},
					gain: {type: "f", value: gain},
					decay: {type: "f", value: decay},
					sensoryVectors: {type: "v2v", value: sensoryVectors},
					sensoryWeights: {type: "fv1", value: sensoryWeights},
				};

				finalUniforms = {
					paintingTexture: { type: "t", value: painting }
				};

				// Create Shaders
				var randomVertexShader     = document.getElementById('randomVertexShader').innerHTML;
				var randomFragmentShader   = document.getElementById('randomFragmentShader').innerHTML;

				var livingVertexShader     = document.getElementById('livingVertexShader').innerHTML;
				var livingFragmentShader   = document.getElementById('livingFragmentShader').innerHTML;

				var paintingVertexShader   = document.getElementById('paintingVertexShader').innerHTML;
				var paintingFragmentShader = document.getElementById('paintingFragmentShader').innerHTML;

				var antCopyVertexShader    = document.getElementById('antCopyVertexShader').innerHTML;
				var antCopyFragmentShader  = document.getElementById('antCopyFragmentShader').innerHTML;

				var antVertexShader        = document.getElementById('antVertexShader').innerHTML;
				var antFragmentShader      = document.getElementById('antFragmentShader').innerHTML;

				var finalVertexShader      = document.getElementById('finalVertexShader').innerHTML;
				var finalFragmentShader    = document.getElementById('finalFragmentShader').innerHTML;

				var randomMaterial = new THREE.ShaderMaterial({
					uniforms: randomUniforms,
					vertexShader: randomVertexShader,
					fragmentShader: randomFragmentShader
				});

				var paintingMaterial = new THREE.ShaderMaterial({
					uniforms: paintingUniforms,
					vertexShader: paintingVertexShader,
					fragmentShader: paintingFragmentShader
				});

				var livingMaterial = new THREE.ShaderMaterial({
					uniforms: livingUniforms,
					vertexShader: livingVertexShader,
					fragmentShader: livingFragmentShader
				});

				var antCopyMaterial = new THREE.ShaderMaterial({
					uniforms: antCopyUniforms,
					vertexShader: antCopyVertexShader,
					fragmentShader: antCopyFragmentShader
				});

				var antMaterial = new THREE.ShaderMaterial({
					uniforms: antUniforms,
					vertexShader: antVertexShader,
					fragmentShader: antFragmentShader
				});

				var finalMaterial = new THREE.ShaderMaterial({
					uniforms: finalUniforms,
					vertexShader: finalVertexShader,
					fragmentShader: finalFragmentShader
				});

				randomMesh = new THREE.Mesh(
						new THREE.PlaneGeometry(width, height, 0),
						randomMaterial
				);

			    paintingMesh = new THREE.Mesh(
						new THREE.PlaneGeometry(width, height, 0),
						paintingMaterial
				);

				livingMesh = new THREE.Mesh(
						new THREE.PlaneGeometry(width, height, 0),
						livingMaterial
				);

				antCopyMesh = new THREE.Mesh(
						new THREE.PlaneGeometry(width, height, 0),
						antCopyMaterial
				);

				antMesh = new THREE.Mesh(
						new THREE.PlaneGeometry(width, height, 0),
						antMaterial
				);

				finalMesh = new THREE.Mesh(
						new THREE.PlaneGeometry(width, height, 0),
						finalMaterial
				);

				randomMesh.material.depthTest = false;
				randomMesh.material.depthWrite = false;

				paintingMesh.material.depthTest = false;
				paintingMesh.material.depthWrite = false;

				livingMesh.material.depthTest = false;
				livingMesh.material.depthWrite = false;

				antMesh.material.depthTest = false;
				antMesh.material.depthWrite = false;

				antCopyMesh.material.depthTest = false;
				antCopyMesh.material.depthWrite = false;

				finalMesh.material.depthTest = false;
				finalMesh.material.depthWrite = false;

				randomScene.add(randomMesh);
				paintingScene.add(paintingMesh);
				livingScene.add(livingMesh);
				antScene.add(antMesh);
				antCopyScene.add(antCopyMesh);
				finalScene.add(finalMesh);
			 
			    renderer = new THREE.WebGLRenderer();
			    renderer.setSize( window.innerWidth, window.innerHeight );
			    document.body.appendChild( renderer.domElement );
			 
			    window.addEventListener( 'resize', onWindowResize, false );

			 
			    //render();

				//requestAnimationFrame( animate );

				var initLiving = THREE.ImageUtils.loadTexture("image/girl.jpg", {}, function() {
					antUniforms.livingTexture.value = initLiving;
					animate();
				});
			}
			 

			function animate() {
				render();

			    requestAnimationFrame( animate );
			}
			 
			function render() {
				renderer.autoClear = false;
				renderer.clear();

				// Init ants
				if(firstExecution == true) {
					firstExecution = false;
					renderer.render(randomScene, camera, ant, true);
				}

				// Update ants
				/*
				antCopyUniforms.antTexture.value = ant;
				antCopyMesh.material.needsUpdate = true;

				antCopy = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				renderer.render( antCopyScene, camera, antCopy, true);
				*/

				antUniforms.antTexture.value = ant;
				antMesh.material.needsUpdate = true;

				ant = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				renderer.render( antScene, camera, ant, true);

				finalUniforms.paintingTexture.value = ant;
				finalMesh.material.needsUpdate = true;

				/*
				// Update living
				living = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
				renderer.render( livingScene, camera, living, true);

				livingUniforms.livingTexture.value = living;
				livingMesh.material.needsUpdate = true;

				// Update painting
				renderer.render( paintingScene, camera, painting, true);
				*/


				// Draw painting on the screen
				renderer.render( finalScene, camera);
			}
			 
			function onWindowResize() {
			    camera.aspect = window.innerWidth / window.innerHeight;
			    camera.updateProjectionMatrix();
			    renderer.setSize( window.innerWidth, window.innerHeight );
			    render();
			}
		</script>
	</body>
</html>